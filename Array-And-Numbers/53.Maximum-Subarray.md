## 53. Maximum Subarray

----
## 题目地址

[https://leetcode.com/problems/maximum-subarray/](https://leetcode.com/problems/maximum-subarray/)

[https://leetcode.com/problems/maximum-subarray/](https://leetcode.com/problems/maximum-subarray/)

## 题目描述

```text
Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

Example:

Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
Follow up:

If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.
```

## 代码

```java
public class Solution {
    public int maxSubArray(ArrayList<Integer> nums) {
    if (nums == null || nums.isEmpty()) return -1;

    int sum = 0, maxSum = Integer.MIN_VALUE;
    for (int num : nums) {
      sum = Math.max(sum, 0);
      sum += num;

      maxSum = Math.max(maxSum, sum);
    }

    return maxSum;
  }
}
```

Solution 2:

```java
public class Solution{
  public int maxSubArray(ArrayList<Integer> nums){
    if (nums == null || nums.isEmpty()) return -1;

    int sum = 0;
    int minSum = 0;
    int maxSub = Integer.MIN_VALUE;
    for (int num : nums) {
      minSum = Math.min(minSum, sum);
      sum += num;
      maxSub = Math.max(maxSub, sum - minSum);
    }

    return maxSub;
  }
}
```

Solution 3:

```java
public class Solution {
  public int maxSubArray(ArrayList<Integer> nums){
    int size = nums.size();
    int[] local = new int[size];
    int[] global = new int[size];
    local[0] = nums.get(0);
    global[0] = nums.get(0);
    for (int i = 1; i < size; i++) {
      // drop local[i - 1] < 0
      local[i] = Math.max(nums.get(i), local[i - 1] + nums.get(i));
      // update global with local
      global[i] = Math.max(global[i - 1], local[i]);
    }
    return global[size - 1];
  }
}
```

Approach 4: Divide & Conquer

**Intuition**

The problem is a classical example of [divide and conquer approach](https://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/), and can be solved with the algorithm similar with the merge sort.

Let's follow here a solution template for the divide and conquer problems :

* Define the base case\(s\).
* Split the problem into subproblems and solve them recursively.
* Merge the solutions for the subproblems to obtain the solution for the original problem.

**Algorithm**

maxSubArray for array with `n` numbers:

* If `n == 1` : return this single element.
* `left_sum` = maxSubArray for the left subarray, _i.e._ for the first `n/2` numbers \(middle element at index `(left + right) / 2` always belongs to the left subarray\).
* `right_sum` = maxSubArray for the right subarray, _i.e._ for the last `n/2` numbers.
* `cross_sum` = maximum sum of the subarray containing elements from both left and right subarrays and hence crossing the middle element at index `(left + right) / 2`.
* Merge the subproblems solutions, _i.e._ return `max(left_sum, right_sum, cross_sum)`.

Complexity Analysis:

Time complexity : O\(_N_log_N_\).

Space complexity : O\(log_N_\) to keep the recursion stack.

```java
class Solution {
  public int maxSubArray(int[] nums) {
    return helper(nums, 0, nums.length - 1);
  }

  public int helper(int[] nums, int left, int right) {
    if (left == right) return nums[left];

    int p = (left + right) / 2;

    int leftSum = helper(nums, left, p);
    int rightSum = helper(nums, p + 1, right);
    int crossSum = crossSum(nums, left, right, p);

    return Math.max(Math.max(leftSum, rightSum), crossSum);
  }

  public int crossSum(int[] nums, int left, int right, int p) {
    if (left == right)    return nums[left];

    int leftSubSum = Integer.MIN_VALUE;
    int currSum = 0;
    for (int i = p; i >= left; i--) {
      currSum += nums[i];
      leftSubSum = Math.max(leftSubSum, currSum);
    }

    int rightSubSum = Integer.MIN_VALUE;
    currSum = 0;
    for (int i = p + 1; i <= right; i++) {
      currSum += nums[i];
      rightSubSum = Math.max(rightSubSum, currSum);
    }

    return leftSubSum + rightSubSum;
  }
}
```

Approach 5: Greedy

Intuition

The problem to find maximum \(or minimum\) element \(or sum\) with a single array as the input is a good candidate to be solved by the greedy approach in linear time.

The algorithm is general and straightforward: iterate over the array and update at each step the standard set for such problems:

* current element
* current _local_ maximum sum \(at this given point\)
* _global_ maximum sum seen so far.

**Complexity Analysis**

* Time complexity : \mathcal{O}\(N\)O\(_N_\) since it's one pass along the array.
* Space complexity : \mathcal{O}\(1\)O\(1\), since it's a constant space solution.

```java
class Solution {
  public int maxSubArray(int[] nums) {
    int n = nums.length;
    int currSum = nums[0];
    int maxSum = nums[0];

    for (int i = 1; i < n; i++) {
      currSum = Math.max(nums[i], currSum + nums[i]);
      maxSum = Math.max(maxSum, currSum);
    }

    return maxSum;
  }
}
```

### Approach 3: Dynamic Programming \(Kadane's algorithm\)

Intuition

The problem to find sum or maximum or minimum in an entire array or in a fixed-size sliding window could be solved by the dynamic programming \(DP\) approach in linear time.

There are two standard DP approaches suitable for arrays:

* Constant space one. Move along the array and modify the array itself.
* Linear space one. First move in the direction `left->right`, then in the direction `right->left`. Combine the results.

**Complexity Analysis**

* Time complexity : O\(_N_\) since it's one pass along the array.
* Space complexity : O\(1\), since it's a constant space solution.

```java
class Solution {
  public int maxSubArray(int[] nums) {
    int n = nums.length;
    int maxSum = nums[0];
    for (int i = 1; i < n; i++) {
      if (nums[i - 1] > 0) {
        nums[i] += nums[i - 1];
      }
      maxSum = Math.max(nums[i], maxSum);
    }

    return maxSum;
  }
}
```

