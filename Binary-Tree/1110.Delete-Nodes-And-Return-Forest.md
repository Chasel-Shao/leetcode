## 1110. Delete Nodes And Return Forest

----
## 题目地址

https://leetcode.com/problems/delete-nodes-and-return-forest/

## 题目描述
```
Given the root of a binary tree, each node in the tree has a distinct value.

After deleting all nodes with a value in to_delete, we are left with a forest (a disjoint union of trees).

Return the roots of the trees in the remaining forest.  You may return the result in any order.

Example 1
Input: root = [1,2,3,4,5,6,7], to_delete = [3,5]
Output: [[1,2,null,4],[6],[7]]
 

Constraints:
The number of nodes in the given tree is at most 1000.
Each node has a distinct value between 1 and 1000.
to_delete.length <= 1000
to_delete contains distinct values between 1 and 1000.
```

## 代码

### Approach #1 Recursion

Time `O(N)`
Space `O(H + N)`, where `H` is the height of tree.

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
  Set<Integer> to_delete_set;
  List<TreeNode> res;
  public List<TreeNode> delNodes(TreeNode root, int[] to_delete) {
		to_delete_set = new HashSet<>();
    res = new ArrayList<>();
    for (int i: to_delete) {
      to_delete_set.add(i);
    }
    helper(root, true);
    return res;
  }
  
  private TreeNode helper(TreeNode node, boolean is_root) {
    if (node == null)		return null;
    boolean deleted = to_delete_set.contains(node.val);
    if (is_root && !deleted)	res.add(node);
    
    node.left = helper(node.left, deleted);
    node.right = helper(node.right, deleted);
    return deleted ? null : node;
  }
}
```















